# 🔒 TODO LIST - PROBLÈME RLS → Table `organisations`

## 📋 ÉTAT ACTUEL - CE QUI EXISTE

### ❌ POLITIQUE RLS ACTUELLE - PROBLÈME CRITIQUE

**Politique existante :**
```sql
Policy Name: "Admin PRESENCA full access organisations"
Command: ALL
Using Expression: is_admin_presenca(auth.uid())
With Check Expression: is_admin_presenca(auth.uid())
```

### 🚨 IMPACT BLOQUANT ACTUEL

#### Qui peut accéder ?
- ✅ **Admins PRESENCA** : Accès total (lecture/écriture)
- ❌ **Utilisateurs normaux** : AUCUN accès, même à leur propre organisation

#### Conséquences business CRITIQUES
```sql
-- Test de l'état actuel
SELECT * FROM organisations WHERE organisation_id = get_user_organisation_id(auth.uid());
-- ❌ RÉSULTAT : Aucune ligne retournée pour utilisateurs non-admin
-- ❌ L'application ne peut pas afficher les infos de l'entreprise
```

**Fonctionnalités cassées pour utilisateurs normaux :**
- ❌ Nom de l'entreprise non affiché
- ❌ Plan d'abonnement invisible  
- ❌ Adresse de facturation inaccessible
- ❌ SIRET non récupérable
- ❌ Statut compte non visible
- ❌ **L'interface client est complètement cassée**

---

## 🎯 CE QU'IL FAUT FAIRE - SOLUTION REQUISE

### ÉTAPE 1 : Ajouter politique de lecture pour utilisateurs

**Politique à créer :**
```sql
CREATE POLICY "Users can view their organisation" 
ON public.organisations 
FOR SELECT 
USING (organisation_id = get_user_organisation_id(auth.uid()));
```

### ÉTAPE 2 : Politique d'écriture restrictive (optionnel)

**Si nécessaire, permettre aux utilisateurs de modifier certains champs :**
```sql
-- Exemple : permettre mise à jour des infos de contact uniquement
CREATE POLICY "Users can update organisation contact info" 
ON public.organisations 
FOR UPDATE 
USING (organisation_id = get_user_organisation_id(auth.uid()))
WITH CHECK (
  organisation_id = get_user_organisation_id(auth.uid()) AND
  -- Limiter aux colonnes non-critiques
  organisation_email = OLD.organisation_email OR
  organisation_telephone = OLD.organisation_telephone OR
  organisation_adresse = OLD.organisation_adresse
);
```

### ÉTAPE 3 : Vérification sécurité

**Tester que la fonction `get_user_organisation_id` est sécurisée :**
```sql
-- ✅ Vérifier que la fonction existe et est SECURITY DEFINER
\df+ get_user_organisation_id

-- ✅ Vérifier qu'elle retourne NULL pour les utilisateurs sans organisation
SELECT get_user_organisation_id('00000000-0000-0000-0000-000000000000');

-- ✅ Vérifier qu'elle fonctionne pour un utilisateur valide  
SELECT get_user_organisation_id(auth.uid());
```

---

## 🔍 ANALYSE TECHNIQUE DÉTAILLÉE

### Architecture multi-tenant actuelle
```
organisations (table principale)
    ↓ organisation_id
users (users_organisation_id → organisations.organisation_id)
    ↓ users_auth_id  
auth.users (Supabase Auth)
```

### Fonction sécurisée existante
```sql
CREATE OR REPLACE FUNCTION public.get_user_organisation_id(user_uuid uuid)
RETURNS uuid
LANGUAGE plpgsql
STABLE SECURITY DEFINER  -- ✅ Sécurisée
SET search_path TO 'public'  -- ✅ Protection injection
AS $function$
DECLARE
  org_id uuid;
BEGIN
  -- ✅ Récupère l'organisation de l'utilisateur
  SELECT users_organisation_id INTO org_id
  FROM users 
  WHERE users_auth_id = user_uuid;
  
  -- ✅ Gestion erreur si pas d'organisation (sauf admin_presenca)
  IF org_id IS NULL THEN
    IF NOT EXISTS (
      SELECT 1 FROM users 
      WHERE users_auth_id = user_uuid 
      AND users_role_systeme = 'admin_presenca'
    ) THEN
      RAISE EXCEPTION 'Utilisateur % non associé à une organisation', user_uuid;
    END IF;
  END IF;
  
  RETURN org_id;
END;
$function$
```

### Pattern de sécurité appliqué
**Ce pattern est déjà utilisé avec succès sur 15+ tables :**
- `abonnement_stripe`
- `agence_independante`  
- `reseau`
- `brevo_connexion`
- etc.

**Toutes ces tables ont :**
```sql
Policy: admin_presenca_full_access_[table] 
Using: is_admin_presenca(auth.uid())

Policy: organisation_only_access_[table]
Using: (organisation_id = get_user_organisation_id(auth.uid()))
```

---

## ⚠️ VÉRIFICATIONS IMPORTANTES

### 1. Fonction `get_user_organisation_id` fonctionne
```sql
-- Test avec utilisateur connecté
SELECT get_user_organisation_id(auth.uid());
-- Doit retourner un UUID valide ou NULL si admin_presenca
```

### 2. Table `users` peuplée correctement
```sql
-- Vérifier que tous les auth.users ont un enregistrement dans public.users
SELECT 
  au.id as auth_user_id,
  u.users_id as public_user_id,
  u.users_organisation_id
FROM auth.users au
LEFT JOIN public.users u ON au.id = u.users_auth_id
WHERE u.users_id IS NULL;
-- Ne doit retourner aucune ligne
```

### 3. Liens organisation cohérents
```sql
-- Vérifier que les organisation_id dans users existent
SELECT u.users_id, u.users_organisation_id, o.organisation_id
FROM public.users u
LEFT JOIN public.organisations o ON u.users_organisation_id = o.organisation_id
WHERE u.users_organisation_id IS NOT NULL 
AND o.organisation_id IS NULL;
-- Ne doit retourner aucune ligne
```

---

## 🚨 IMPACT BUSINESS DE CE PROBLÈME

### FONCTIONNEL
- 🔴 **Application inutilisable** pour utilisateurs normaux
- 🔴 **Interface client cassée** complètement
- 🔴 **Multi-tenancy non fonctionnelle**

### SÉCURITÉ  
- 🟡 **Trop restrictif** mais pas de faille sécurité
- 🟡 **Principe moindre privilège** respecté (trop même)

### BUSINESS
- 🔴 **Perte clients** : Application ne fonctionne pas
- 🔴 **Support débordé** : Utilisateurs ne voient rien
- 🔴 **Réputation** : Produit perçu comme défaillant

---

## ✅ RÉSULTAT ATTENDU APRÈS CORRECTION

### Interface utilisateur fonctionnelle
- ✅ Affichage nom entreprise
- ✅ Informations d'abonnement visibles
- ✅ Données de facturation accessibles  
- ✅ Multi-tenancy opérationnelle

### Sécurité maintenue
- ✅ Utilisateurs voient uniquement LEUR organisation
- ✅ Admins PRESENCA gardent accès total
- ✅ Isolation entre organisations respectée

### Tests de validation
```sql
-- Test utilisateur normal
SELECT organisation_nom FROM organisations; 
-- ✅ Doit retourner 1 ligne (son organisation)

-- Test admin PRESENCA  
SELECT COUNT(*) FROM organisations;
-- ✅ Doit retourner toutes les organisations
```

### Score sécurité
- **Avant** : 90/100 (trop restrictif)
- **Après** : 95/100 (équilibré optimal)