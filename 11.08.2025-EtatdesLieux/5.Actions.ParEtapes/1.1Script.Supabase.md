BEGIN;

-------------------------------------------
-- 1. ACTIVATION RLS + POLICIES ORGANISATIONS
-------------------------------------------

-- Audit préalable des policies liées
SELECT schemaname, tablename, policyname 
FROM pg_policies 
WHERE tablename LIKE '%organisation%' OR policyname LIKE '%organisation%';

-- Activation RLS
ALTER TABLE organisations ENABLE ROW LEVEL SECURITY;

-- SELECT : Admin global OU organisation courante
CREATE POLICY organisations_select_by_org
ON organisations FOR SELECT
USING (
  is_admin_presenca(auth.uid())
  OR organisation_id = get_user_organisation_id(auth.uid())
);

-- UPDATE : même condition en USING + WITH CHECK
CREATE POLICY organisations_update_by_org
ON organisations FOR UPDATE
USING (
  is_admin_presenca(auth.uid())
  OR organisation_id = get_user_organisation_id(auth.uid())
)
WITH CHECK (
  is_admin_presenca(auth.uid())
  OR organisation_id = get_user_organisation_id(auth.uid())
);

-- DELETE : Admin uniquement
CREATE POLICY organisations_delete_admin_only
ON organisations FOR DELETE
USING (is_admin_presenca(auth.uid()));

-- INSERT : Admin uniquement
CREATE POLICY organisations_insert_admin_only
ON organisations FOR INSERT
WITH CHECK (is_admin_presenca(auth.uid()));

-------------------------------------------
-- 2. TRIGGERS D’AUDIT – ORGANISATIONS, USERS, UTILISATEURS
-------------------------------------------

-- Vérification fonctions d’audit
SELECT proname FROM pg_proc WHERE proname LIKE '%audit%' ORDER BY proname;

-- Exemple fonctions spécialisées si manquantes
-- ORGANISATIONS
CREATE OR REPLACE FUNCTION set_created_audit_fields_organisations()
RETURNS TRIGGER AS $$
BEGIN
  NEW.created_at := now();
  NEW.created_by := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION update_audit_fields_organisations()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := now();
  NEW.updated_by := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- USERS
CREATE OR REPLACE FUNCTION set_created_audit_fields_users()
RETURNS TRIGGER AS $$
BEGIN
  NEW.created_at := now();
  NEW.created_by := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION update_audit_fields_users()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := now();
  NEW.updated_by := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- UTILISATEURS
CREATE OR REPLACE FUNCTION set_created_audit_fields_utilisateurs()
RETURNS TRIGGER AS $$
BEGIN
  NEW.created_at := now();
  NEW.created_by := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION update_audit_fields_utilisateurs()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := now();
  NEW.updated_by := auth.uid();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Création triggers ORGANISATIONS
DROP TRIGGER IF EXISTS organisations_insert_audit ON organisations;
CREATE TRIGGER organisations_insert_audit
BEFORE INSERT ON organisations
FOR EACH ROW EXECUTE FUNCTION set_created_audit_fields_organisations();

DROP TRIGGER IF EXISTS organisations_update_audit ON organisations;
CREATE TRIGGER organisations_update_audit
BEFORE UPDATE ON organisations
FOR EACH ROW EXECUTE FUNCTION update_audit_fields_organisations();

-- Création triggers USERS
DROP TRIGGER IF EXISTS users_insert_audit ON users;
CREATE TRIGGER users_insert_audit
BEFORE INSERT ON users
FOR EACH ROW EXECUTE FUNCTION set_created_audit_fields_users();

DROP TRIGGER IF EXISTS users_update_audit ON users;
CREATE TRIGGER users_update_audit
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION update_audit_fields_users();

-- Création triggers UTILISATEURS
DROP TRIGGER IF EXISTS utilisateurs_insert_audit ON utilisateurs;
CREATE TRIGGER utilisateurs_insert_audit
BEFORE INSERT ON utilisateurs
FOR EACH ROW EXECUTE FUNCTION set_created_audit_fields_utilisateurs();

DROP TRIGGER IF EXISTS utilisateurs_update_audit ON utilisateurs;
CREATE TRIGGER utilisateurs_update_audit
BEFORE UPDATE ON utilisateurs
FOR EACH ROW EXECUTE FUNCTION update_audit_fields_utilisateurs();

-------------------------------------------
-- 3. SECURISATION FONCTIONS CRITIQUES
-------------------------------------------

-- get_user_organisation_id
CREATE OR REPLACE FUNCTION get_user_organisation_id(user_uuid uuid)
RETURNS uuid
LANGUAGE sql
SECURITY DEFINER
SET search_path = 'public'
AS $$
  SELECT organisation_id
  FROM users
  WHERE users_auth_id = user_uuid
  LIMIT 1;
$$;

-- log_audit_event
CREATE OR REPLACE FUNCTION log_audit_event(action text, details jsonb)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  INSERT INTO "1_historique_supabase"(organisation_id, action, details, historique_created_at)
  VALUES (get_user_organisation_id(auth.uid()), action, details, now());
END;
$$;

-------------------------------------------
-- 4. FK USERS → ORGANISATIONS
-------------------------------------------

-- Vérification intégrité
SELECT COUNT(*) AS orphelins
FROM users u
LEFT JOIN organisations o ON u.users_organisation_id = o.organisation_id
WHERE o.organisation_id IS NULL;

-- Ajout FK si 0 orphelins
ALTER TABLE users
ADD CONSTRAINT fk_users_organisation
FOREIGN KEY (users_organisation_id)
REFERENCES organisations(organisation_id)
ON DELETE RESTRICT;

-------------------------------------------
-- 5. INDEX & MONITORING
-------------------------------------------

-- Index utiles
CREATE INDEX IF NOT EXISTS idx_users_organisation_id ON users(users_organisation_id);
CREATE INDEX IF NOT EXISTS idx_audit_organisation_date 
ON "1_historique_supabase"(organisation_id, historique_created_at);

-- Fonction monitoring
CREATE OR REPLACE FUNCTION supabase_health_check()
RETURNS text
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN 'OK - ' || now();
END;
$$;

COMMIT;
