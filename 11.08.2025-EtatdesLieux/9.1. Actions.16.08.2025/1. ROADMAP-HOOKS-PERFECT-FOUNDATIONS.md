# Roadmap Hooks — Perfect Foundations (v1)

> Objectif : remettre l’authentification et le multi-tenant sur des bases saines, **sans dérives**.  
> Règle d’or : **1 étape à la fois.** À la fin de chaque étape : **STOP** (ne rien corriger ailleurs, ne pas lancer d’autres modifs).  
> En cas d’erreur build ou runtime : **NE PAS corriger** ; **remonter le problème et attendre validation**.

---

## Étape 1 — `useAuth` (auth **pure**)

**BUT**  
Centraliser **uniquement** session/tokens + actions (sans aucun métier, ni redirection).

**À FAIRE (Lovable)**  
1. **Créer** `src/hooks/useAuth.ts`.  
2. Ne pas toucher aux pages : on branchera plus tard.  
3. Interdiction **formelle** d’utiliser `user_metadata`.

**CODE À COLLER — `src/hooks/useAuth.ts`**
```ts
// src/hooks/useAuth.ts
import { useEffect, useMemo, useState, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import type { Session, User } from "@supabase/supabase-js";

type AuthOk = { ok: true; code?: string; message?: string };
type AuthErr = { ok: false; code?: string; message: string };
export type AuthResult = AuthOk | AuthErr;

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initial session load
  useEffect(() => {
    let mounted = true;
    (async () => {
      const { data } = await supabase.auth.getSession();
      if (!mounted) return;
      setSession(data.session ?? null);
      setUser(data.session?.user ?? null);
      setIsLoading(false);
    })();

    const { data: sub } = supabase.auth.onAuthStateChange((_event, sess) => {
      setSession(sess ?? null);
      setUser(sess?.user ?? null);
    });

    return () => {
      mounted = false;
      sub.subscription.unsubscribe();
    };
  }, []);

  const isAuthenticated = useMemo(() => !!user && !!session, [user, session]);

  const signIn = useCallback(async (email: string, password: string): Promise<AuthResult> => {
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) return { ok: false, code: error.status?.toString(), message: error.message };
    return { ok: true };
  }, []);

  const signUp = useCallback(async (email: string, password: string): Promise<AuthResult> => {
    const { error } = await supabase.auth.signUp({ email, password });
    if (error) return { ok: false, code: error.status?.toString(), message: error.message };
    return { ok: true };
  }, []);

  const signOut = useCallback(async (): Promise<void> => {
    await supabase.auth.signOut();
  }, []);

  const resetPassword = useCallback(async (email: string): Promise<AuthResult> => {
    const { error } = await supabase.auth.resetPasswordForEmail(email);
    if (error) return { ok: false, code: error.status?.toString(), message: error.message };
    return { ok: true };
  }, []);

  const signInWithProvider = useCallback(
    async (provider: "google"): Promise<AuthResult> => {
      const { error } = await supabase.auth.signInWithOAuth({ provider });
      if (error) return { ok: false, code: error.status?.toString(), message: error.message };
      return { ok: true };
    },
    []
  );

  return {
    // state
    user,
    session,
    isAuthenticated,
    isLoading,
    // actions
    signIn,
    signUp,
    signOut,
    resetPassword,
    signInWithProvider,
  };
}
```

**STOP**  
- Ne branche pas encore la page login.  
- Ne fais aucune redirection.  
- Si une erreur apparaît, **remonte-la**, n’essaie pas de la corriger.

---

## Étape 2 — RPC & `useCurrentUser` (profil métier consolidé, corrigé)

**BUT**  
Récupérer **depuis la base** le profil joint `users + utilisateurs + organisations` via **un RPC**.  
> Nom recommandé du RPC côté DB : `get_current_user_organisation()`.

**À FAIRE (Lovable)**  
1. **Créer** `src/hooks/useCurrentUser.ts`.  
2. Le hook **ne s’exécute** que si `useAuth.isAuthenticated === true`.  
3. **Aucun** recours à `user_metadata`.  
4. **Ne pas** ajouter de redirection.  
5. Vérifier la validité du schéma RPC et prévoir un fallback si incomplet.

**CODE À COLLER — `src/hooks/useCurrentUser.ts`**
```ts
// src/hooks/useCurrentUser.ts
import { useEffect, useState, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "./useAuth";

export type CurrentUserProfile = {
  user_id: string;
  email: string;
  users_role_systeme: string | null;
  users_role: string | null;
  users_interface_par_defaut: string | null;

  utilisateur_id: string | null;
  organisation_id: string | null;
  utilisateur_type_compte: string | null;
  utilisateur_role: string | null;
  utilisateur_statut: string | null;

  organisation_nom: string | null;
  organisation_statut_compte: string | null;
  organisation_statut_paiement: string | null;
};

type State =
  | { status: "idle"; profile: null; error: null }
  | { status: "loading"; profile: null; error: null }
  | { status: "ready"; profile: CurrentUserProfile; error: null }
  | { status: "error"; profile: null; error: string };

function isValidProfile(data: any): data is CurrentUserProfile {
  return data && typeof data === "object" && "user_id" in data && "email" in data;
}

export function useCurrentUser() {
  const { isAuthenticated } = useAuth();
  const [state, setState] = useState<State>({ status: "idle", profile: null, error: null });

  const fetchProfile = useCallback(async () => {
    if (!isAuthenticated) {
      setState({ status: "idle", profile: null, error: null });
      return;
    }
    setState({ status: "loading", profile: null, error: null });
    const { data, error } = await supabase.rpc("get_current_user_organisation");
    if (error) {
      setState({ status: "error", profile: null, error: error.message });
      return;
    }
    if (!isValidProfile(data)) {
      setState({ status: "error", profile: null, error: "Profil RPC invalide ou incomplet" });
      return;
    }
    setState({ status: "ready", profile: data as CurrentUserProfile, error: null });
  }, [isAuthenticated]);

  useEffect(() => {
    fetchProfile();
  }, [fetchProfile]);

  return {
    profile: state.status === "ready" ? state.profile : null,
    isLoading: state.status === "loading",
    error: state.status === "error" ? state.error : null,
    refreshProfile: fetchProfile,
  };
}
```

**STOP**  
- **Ne crée pas** de routes, **ne redirige pas**.  
- Si le RPC n’existe pas encore côté DB : **ne pas improviser** ; remonter l’info et attendre validation.

---

## Étape 3 — Utilitaire `getRedirectPath(profile)` (navigation centralisée)

**BUT**  
Avoir **un seul calcul** de la route cible basée **uniquement** sur les données BD du `profile`.

**RÈGLE DE REDIRECTION (validée)**  
- `admin_presenca` / `superadmin` → `/admin-presenca`  
- `reseau` / `reseau_direction` → `/espace-reseau`  
- autres → `/accueil-leadgenai`

**À FAIRE (Lovable)**  
1. **Créer** `src/utils/getRedirectPath.ts`.  
2. Utiliser **exclusivement** `profile` (pas de metadata).

**CODE À COLLER — `src/utils/getRedirectPath.ts`**
```ts
// src/utils/getRedirectPath.ts
import type { CurrentUserProfile } from "@/hooks/useCurrentUser";

export function getRedirectPath(profile: CurrentUserProfile | null): string {
  if (!profile) return "/accueil-leadgenai";

  const sys = profile.users_role_systeme ?? null;
  if (sys === "admin_presenca" || sys === "superadmin") return "/admin-presenca";

  const type = (profile.utilisateur_type_compte ?? "").toLowerCase();
  if (type === "reseau" || type === "reseau_direction") return "/espace-reseau";

  return "/accueil-leadgenai";
}
```

**STOP**  
- Ne pas appeler ce helper dans l’UI pour l’instant.  
- Ne créer aucune route, ne modifier aucun layout.

---

## Étape 4 — `useMultiTenant` (organisation effective & impersonation)

**BUT**  
Exposer l’`effectiveOrganisationId` et **préparer** l’impersonation (sans stockage local).

**À FAIRE (Lovable)**  
1. **Créer** `src/hooks/useMultiTenant.ts`.  
2. Ne pas implémenter de persistence locale ; uniquement l’API et l’état.

**CODE À COLLER — `src/hooks/useMultiTenant.ts`**
```ts
// src/hooks/useMultiTenant.ts
import { useState, useMemo, useCallback } from "react";
import type { CurrentUserProfile } from "./useCurrentUser";

export function useMultiTenant(profile: CurrentUserProfile | null) {
  const [impersonatedOrgId, setImpersonatedOrgId] = useState<string | null>(null);

  const effectiveOrganisationId = useMemo(() => {
    return impersonatedOrgId ?? (profile?.organisation_id ?? null);
  }, [impersonatedOrgId, profile?.organisation_id]);

  const startImpersonation = useCallback((organisationId: string) => {
    setImpersonatedOrgId(organisationId);
  }, []);

  const stopImpersonation = useCallback(() => {
    setImpersonatedOrgId(null);
  }, []);

  return {
    effectiveOrganisationId,
    startImpersonation,
    stopImpersonation,
    isImpersonating: impersonatedOrgId !== null,
  };
}
```

**STOP**  
- Ne branche pas de stockage (localStorage, etc.).  
- Ne manipule aucune autre ressource.

---

## Étape 5 — Raccord UI **minimal** (page login uniquement)

**BUT**  
Brancher **la page login** sur `useAuth` **sans** ajouter d’autres logiques.

**À FAIRE (Lovable)**  
1. Dans la page login **uniquement**, remplacer l’appel direct à Supabase par `useAuth().signIn(...)`.  
2. Ne **pas** ajouter de redirection.  
3. Ne **pas** toucher aux autres pages.

**EXEMPLE D’USAGE (à adapter, pas de refactor UI)**
```ts
// dans la page login (extrait):
const { signIn, isLoading } = useAuth();
// on submit:
await signIn(email, password);
```

**STOP**  
- Si la page demande d’autres données, **ne pas** les brancher maintenant.  
- Ne pas ajouter de toasts/global state. Remonter les besoins si nécessaire.

---

## Étape 6 — Redirection post-login (en un point unique)

**BUT**  
Appliquer la redirection **centralisée** après récupération du `profile`.

**À FAIRE (Lovable)**  
1. Dans le **container racine** (ou le layout protégé), après auth **et** chargement de `useCurrentUser`, **appeler** `getRedirectPath(profile)` et faire la navigation.  
2. Ne pas dupliquer la logique dans plusieurs composants.

**PSEUDO-USAGE (sans détails UI/router)**
```ts
const { isAuthenticated } = useAuth();
const { profile, isLoading } = useCurrentUser();

useEffect(() => {
  if (!isAuthenticated || isLoading) return;
  const target = getRedirectPath(profile);
  // router.navigate(target)
}, [isAuthenticated, isLoading, profile]);
```

**STOP**  
- Ne pas ajouter de cas “spéciaux”.  
- Si un profil est incomplet, **remonter l’info** (ne pas bricoler).

---

## Étape 7 — Nettoyage & gel

**BUT**  
S’assurer qu’aucun ancien hook / client ne subsiste.

**À FAIRE (Lovable)**  
1. Supprimer **définitivement** les anciens hooks (obsolètes).  
2. Confirmer qu’**un** seul client Supabase est référencé.

**STOP (final)**  
- Aucun “bonus feature”.  
- Aucun correctif opportuniste.  
- Remonter les anomalies éventuelles et **attendre** arbitrage.

---

### Rappel disciplinaire à Lovable

> **Discipline d’exécution :**  
> - Exécuter **exactement** l’étape en cours, **rien de plus**.  
> - **Ne pas corriger** les erreurs build/runtime : **les remonter** et **STOP**.  
> - **Ne pas** modifier d’autres fichiers que ceux listés dans l’étape.  
> - Attendre validation avant de passer à l’étape suivante.
